---
title: "IPC 管道"
date: 2024-02-23T13:28:32+08:00
draft: true
categories: [linux]
---

管道（Pipe）是一种在类 Unix 系统中，用于进程间通信的机制。它允许一个进程的输出直接成为另一个进程的输入，常见于命令行环境，它能够将一个命令的输出作为另一个命令的输入，从而使两个命令能够协同工作，如`ls -l | grep "txt"`、`cat file.txt | wc -l`。

在 Linux 系统中，管道通常是匿名的，这意味着他们没有在文件系统中显示的路径，而是通过在内核中创建的特殊文件描述符来实现。

创建匿名管道（Anonymous Pipes），需使用系统调用 `int pipe(int fd[2])` ，这里表示创建一个匿名管道，并返回两个描述符。一个是管道的读取端描述符`fd[0]`，另一个是写入端描述符`fd[1]`。**匿名管道是特殊的文件，只存在于内存，不存在于文件系统中**。

这里需要注意的是，在某个进程创建匿名管道，该管道的两个描述符在同一进程中，如何起到跨进程通信的作用？

实际上，匿名管道用于具具有亲缘关系的进程之间的通信，当我们在父进程中调用 `fork()` 系统调用创建子进程并需要父子进程通信时，父进程和子进程可以通过共享的文件描述符进行通信。

一般情况下，父进程关闭管道的读取端，子进程关闭管道的写入端。这样，父进程只写入，子进程只读取，避免了同时写或同时读的情况。

通信完成后，父子进程应该关闭不再需要的文件描述符。关闭管道的写入端（读取端）会导致对应读取端（写入端）收到一个文件结束符，这样读取操作就会返回 0，表述数据已经全部读取完毕。

```c
//匿名管道示例
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#define BUFFER_SIZE 25
#define READ_END 0
#define WRITE_END 1

int main() {
    char write_msg[BUFFER_SIZE] = "Hello, pipe!";
    char read_msg[BUFFER_SIZE];
    int fd[2];
    pid_t pid;

    // 创建管道
    if (pipe(fd) == -1) {
        fprintf(stderr, "Pipe failed");
        return 1;
    }

    // 创建子进程
    pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork failed");
        return 1;
    }

    if (pid > 0) {  // 父进程
        close(fd[READ_END]);  // 关闭读取端

        // 写入数据到管道
        write(fd[WRITE_END], write_msg, strlen(write_msg) + 1);
        close(fd[WRITE_END]);  // 关闭写入端
        printf("Parent process wrote to the pipe: %s\n", write_msg);
    } else {  // 子进程
        close(fd[WRITE_END]);  // 关闭写入端

        // 从管道中读取数据
        read(fd[READ_END], read_msg, BUFFER_SIZE);
        printf("Child process read from the pipe: %s\n", read_msg);
        close(fd[READ_END]);  // 关闭读取端
    }

    return 0;
}
```

对于命名管道（Named Pipes，或 FIFOs），它是一种具有名称的特殊文件，存储在文件系统中，可以通过文件系统路径进行访问，允许无关进程之间进行通信，通过 `mkfifo` 命令或 `mkfifo()` 函数创建。

一个进程可以向命名管道中写入数据，另一个进程可以从命名管道中读取数据。其读写操作和普通文件的读写操作类似，可以使用文件 I/O 函数（`opoen()`/`read()/`/`write()`/`close()`）来进行。

命名管道区别于匿名管道的主要特征在于持久性，即使创建它的进程终止，命名管道仍然存在于文件系统中，直到显示地被删除。

所谓管道，其实就是内核里面的一串缓存。

当进程向管道写入数据时，内核会将数据缓存到管道的内部缓冲区。如果管道的缓冲区已满，写入操作会被阻塞，直到有足够的空间可以写入数据。类似的，当进程从管道读取数据时，内核会从管道的内部缓冲区中读取数据，并将其提供给进程。如果管道的缓冲区为空，读取操作会被阻塞，直到有数据可供读取。

管道的读写操作通常会涉及到进程的同步和通知机制。内核需要保证在多个进程同时访问管道时，数据的读写操作是安全和正确的。为了实现进程的同步和通知，Linux 内核可能会使用信号量、锁或者其它同步机制来保护管道的读写操作，以确保数据的一致性和正确性。

因此，管道这种通信方式效率低，不适合进程间频繁地交换数据。

总的来说，管道作为一种基本的进程间通信机制，在使用时虽然简单方便，但也存在一些弊端，主要体现在：

1. 单向通信：这意味着如果需要双向通信，需要创建两个管道，增加复杂度和开销；
2. 容量限制：管道有一个固定容量限制，一般取决于操作系统的设置。一旦缓冲区达到容量上限，写入操作将被阻塞，可能导致进程间通信的延迟或死锁；
3. 阻塞式读写：管道空或满时，读写操作会被阻塞，这可能导致进程被挂起，降低系统的响应速度；
4. 没有数据完整性保证：管道进提供数据流传输，对完整性和可靠性没有保证，通常需要在应用层面实现额外的机制，如校验和、确认应答等；
5. 无法在网络上使用：管道只能在同一台主机的进程间通信，无法用于网络通信。